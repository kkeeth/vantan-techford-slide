---
theme: default
background: https://picsum.photos/1920/1080
class: text-center
highlighter: shiki
lineNumbers: false
info: |
  ## TypeScript + React ハンズオン講座
  第20回：自動テスト入門
fonts:
  sans: "Josefin Sans"
  serif: "Noto Sans JP"
  mono: "Fira Code"

drawings:
  persist: false
transition: slide-left
title: TypeScript/React 入門講義
---

# TypeScript + React<br>ハンズオン講座

## 第20回：自動テスト入門

<div class="pt-12">
  <span @click="$slidev.nav.next" class="px-2 py-1 rounded cursor-pointer" hover="bg-white bg-opacity-10">
    Press Space for next page <carbon:arrow-right class="inline"/>
  </span>
</div>

<div class="abs-br m-6 flex gap-2">
  <button @click="$slidev.nav.openInEditor()" title="Open in Editor" class="text-xl slidev-icon-btn opacity-50 !border-none !hover:text-white">
    <carbon:edit />
  </button>
</div>

<style>
  h1 {
    color: #fff;
  }
</style>

---
layout: section
---

# 出席確認

---
layout: default
---

# 本日の内容

<Toc minDepth="2" maxDepth="2" />

<style>
h2 {
  margin: 1rem 0;
}
</style>

## 自動テストでコードの品質を守ろう!

---
layout: section
---

# 自動テスト入門

---

# 目次

## 1. 自動テストとは
## 2. テスト環境のセットアップ
## 3. 最初のテストを書く
## 4. React コンポーネントのテスト
## 5. チャットアプリのテスト実践
## 6. カバレッジの確認

※今回は Vitest + React Testing Library を使ってユニットテストを学びます.

<style>
h2 {
  margin-bottom: .5rem;
}
</style>

---

# 1. 自動テストとは

## 1.1 なぜテストが必要なのか

<div grid="~ cols-2 gap-4">
<div>

**テストがないと...**

- コードを変更するたびに不安になる
- バグに気づかないままリリースしてしまう
- 「動いているから触らない」コードが増える
- リファクタリングが怖くてできない

**テストがあると...**

- 変更しても壊れていないことを確認できる
- バグを早期に発見できる
- 安心してコードを改善できる
- ドキュメント代わりにもなる

</div>
<div>

```
変更前のコード
     ↓
コードを修正
     ↓
テストを実行 ← 自動で確認!
     ↓
  ┌─────────────┐
  │ 全てパス?   │
  └─────────────┘
    ↓ Yes    ↓ No
  リリース   修正
```

テストは「安心して開発を続けるための保険」です.

</div>
</div>

---

## 1.2 テストの種類

テストにはいくつかの種類があります:

<div grid="~ cols-2 gap-4">
<div>

**ユニットテスト（単体テスト）**
- 関数やコンポーネント単位でテスト
- 実行が速い
- 今回のメインテーマ

**統合テスト（Integration Test）**
- 複数のコンポーネントの連携をテスト
- API との連携なども確認

</div>
<div>

**E2E テスト（End-to-End）**
- ブラウザを自動操作してテスト
- ユーザーの操作を再現
- Playwright, Cypress などを使用
- 実行に時間がかかる

**VRT（Visual Regression Test）**
- 見た目の変化を検出
- スクリーンショットを比較
- Chromatic, Percy などを使用

</div>
</div>

---

## 1.3 テストピラミッド

<div grid="~ cols-2 gap-4">
<div>

```
        /\
       /  \
      / E2E \      ← 少なく, 遅い
     /--------\
    /   統合   \    ← 中程度
   /--------------\
  /   ユニット    \  ← 多く, 速い
 /------------------\
```

**テストピラミッドの考え方:**
- 下層ほど多く, 速く, 安定
- 上層ほど少なく, 遅く, 不安定

</div>
<div>

**今回学ぶのは「ユニットテスト」**

ユニットテストは:
- 実行が高速（数秒〜数十秒）
- 問題箇所が特定しやすい
- 書きやすく, 保守しやすい
- CI/CD で毎回実行できる

まずはここから始めましょう!

</div>
</div>

---

# 2. テスト環境のセットアップ

## 2.1 Vitest とは

<div grid="~ cols-2 gap-4">
<div>

**Vitest** は Vite ベースの高速なテストフレームワークです.

**特徴:**
- Vite と同じ設定を共有できる
- Jest 互換の API
- TypeScript をネイティブサポート
- HMR によるテストの高速再実行
- ESM ファーストの設計

</div>
<div>

**なぜ Jest ではなく Vitest?**

- Vite プロジェクトとの相性が抜群
- 設定がシンプル
- ESM のサポートが良い
- 実行速度が速い

```bash
# Jest vs Vitest の実行速度
Jest:    ~5秒
Vitest:  ~1秒
```

</div>
</div>

---

## 2.2 必要なパッケージのインストール

チャットアプリのディレクトリで以下を実行します:

```bash
cd assets/chat

# Vitest と Testing Library をインストール
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom
```

**インストールするパッケージの説明:**

| パッケージ | 役割 |
|-----------|------|
| `vitest` | テストフレームワーク本体 |
| `@testing-library/react` | React コンポーネントをテストするためのユーティリティ |
| `@testing-library/jest-dom` | DOM に対するカスタムマッチャー |
| `@testing-library/user-event` | ユーザー操作をシミュレート |
| `jsdom` | ブラウザ環境をエミュレート |

---

## 2.3 Vitest の設定

<div grid="~ cols-2 gap-4">
<div>

**vite.config.ts を更新:**

```ts
// vite.config.ts
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
    css: true,
  },
});
```

</div>
<div>

**設定の説明:**

- `globals: true` - describe, it, expect をグローバルに
- `environment: 'jsdom'` - ブラウザ環境をエミュレート
- `setupFiles` - テスト前に実行するファイル
- `css: true` - CSS をテスト時も処理

</div>
</div>

---

## 2.4 セットアップファイルの作成

<div grid="~ cols-2 gap-4">
<div>

`src/test/setup.ts` ファイルを作成:

```ts
// src/test/setup.ts
import '@testing-library/jest-dom';
```

このファイルで `jest-dom` のカスタムマッチャーを読み込みます.

**カスタムマッチャーの例:**
- `toBeInTheDocument()`
- `toBeVisible()`
- `toHaveTextContent()`
- `toBeDisabled()`

</div>
<div>

**TypeScript の型定義を追加:**

```diff
// tsconfig.json
{
  "compilerOptions": {
+   "types": ["vitest/globals"]
  }
}
```

これで `describe`, `it`, `expect` などの型が認識されます.

</div>
</div>

---

## 2.5 package.json にスクリプトを追加

```diff
// package.json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint src --ext ts,tsx",
+   "test": "vitest",
+   "test:run": "vitest run",
+   "test:coverage": "vitest run --coverage"
  }
}
```

**スクリプトの説明:**
- `npm test` - ウォッチモードでテストを実行（ファイル変更を監視）
- `npm run test:run` - テストを1回だけ実行
- `npm run test:coverage` - カバレッジレポート付きで実行

---

# 3. 最初のテストを書く

## 3.1 テストの基本構造

<div grid="~ cols-2 gap-4">
<div>

```ts
// src/utils/sample.test.ts
import { describe, it, expect } from 'vitest';
import { add } from './sample';

describe('add 関数', () => {
  it('2つの数値を足し算できる', () => {
    const result = add(1, 2);
    expect(result).toBe(3);
  });

  it('負の数も扱える', () => {
    const result = add(-1, 1);
    expect(result).toBe(0);
  });
});
```

</div>
<div>

**テストの3つの要素:**

1. **describe** - テストをグループ化
2. **it** (または `test`) - 個別のテストケース
3. **expect** - 結果を検証

**AAA パターン:**
- **Arrange** - 準備（データや状態を用意）
- **Act** - 実行（テスト対象を呼び出す）
- **Assert** - 検証（結果を確認）

</div>
</div>

---

## 3.2 よく使う Matcher

<div grid="~ cols-2 gap-4">
<div>

**基本的な Matcher:**

```ts
// 等価性
expect(value).toBe(3);           // 厳密等価
expect(obj).toEqual({ a: 1 });   // オブジェクト比較

// 真偽値
expect(value).toBeTruthy();
expect(value).toBeFalsy();
expect(value).toBeNull();
expect(value).toBeUndefined();

// 数値
expect(value).toBeGreaterThan(3);
expect(value).toBeLessThan(10);
```

</div>
<div>

**文字列・配列:**

```ts
// 文字列
expect(str).toContain('hello');
expect(str).toMatch(/pattern/);

// 配列
expect(arr).toContain(item);
expect(arr).toHaveLength(3);

// 例外
expect(() => fn()).toThrow();
expect(() => fn()).toThrow('error message');
```

</div>
</div>

---

## 3.3 実践: ユーティリティ関数のテスト

チャットアプリの `validateMessage` 関数をテストしてみましょう:

<div grid="~ cols-2 gap-4">
<div>

**テスト対象の関数:**

```ts
// src/utils/validator.ts
const MAX_MESSAGE_LENGTH = 140;

export const validateMessage = (str: string): string => {
  if (!str.trim()) {
    return '内容を入力してください';
  }
  if (str.length > MAX_MESSAGE_LENGTH) {
    return `${MAX_MESSAGE_LENGTH} 文字以内で入力`;
  }
  return '';
};
```

</div>
<div>

**テストコード:**

```ts
// src/utils/validator.test.ts
import { describe, it, expect } from 'vitest';
import { validateMessage } from './validator';

describe('validateMessage', () => {
  it('空文字の場合はエラーを返す', () => {
    expect(validateMessage('')).toBe('内容を入力してください');
  });

  it('空白のみの場合もエラーを返す', () => {
    expect(validateMessage('   ')).toBe('内容を入力してください');
  });

  it('正常な入力の場合は空文字を返す', () => {
    expect(validateMessage('こんにちは')).toBe('');
  });
});
```

</div>
</div>

---

## 3.4 テストを実行してみよう

```bash
# ウォッチモードでテストを実行
npm test
```

**実行結果:**

```
 ✓ src/utils/validator.test.ts (3)
   ✓ validateMessage (3)
     ✓ 空文字の場合はエラーを返す
     ✓ 空白のみの場合もエラーを返す
     ✓ 正常な入力の場合は空文字を返す

 Test Files  1 passed (1)
      Tests  3 passed (3)
   Start at  14:30:00
   Duration  1.23s
```

全てのテストがパスしました!

---

## 3.5 追加のテストケース

<div grid="~ cols-2 gap-4">
<div>

**境界値テストを追加:**

```ts
describe('validateMessage', () => {
  // ...前のテスト

  it('140文字ちょうどは有効', () => {
    const text = 'あ'.repeat(140);
    expect(validateMessage(text)).toBe('');
  });

  it('141文字以上はエラー', () => {
    const text = 'あ'.repeat(141);
    expect(validateMessage(text)).toContain('140');
  });
});
```

</div>
<div>

**テストのポイント:**

**境界値テスト**が重要です:
- ちょうど140文字 → OK
- 141文字 → NG

境界の「両側」をテストすることで, バグを見つけやすくなります.

**よくあるバグ:**
- `>` と `>=` の間違い
- `<` と `<=` の間違い

</div>
</div>

---

# 4. React コンポーネントのテスト

## 4.1 Testing Library の考え方

<div grid="~ cols-2 gap-4">
<div>

**Testing Library の哲学:**

> The more your tests resemble the way your software is used, the more confidence they can give you.

「テストがユーザーの使い方に似ているほど, より信頼できる」

**実装の詳細ではなく, ユーザーが見るものをテストする**

</div>
<div>

**悪い例:**

```tsx
// 実装の詳細をテストしている
expect(component.state.isOpen).toBe(true);
expect(wrapper.find('.internal-class')).toExist();
```

**良い例:**

```tsx
// ユーザーが見るものをテストしている
expect(screen.getByText('メニュー')).toBeVisible();
expect(screen.getByRole('button')).toBeEnabled();
```

</div>
</div>

---

## 4.2 render と screen の基本

<div grid="~ cols-2 gap-4">
<div>

**基本的なコンポーネントテスト:**

```tsx
// src/components/Button.test.tsx
import { render, screen } from '@testing-library/react';
import { Button } from './Button';

describe('Button', () => {
  it('テキストが表示される', () => {
    render(<Button>クリック</Button>);

    expect(screen.getByText('クリック'))
      .toBeInTheDocument();
  });
});
```

</div>
<div>

**render と screen の役割:**

- `render()` - コンポーネントを仮想 DOM にレンダリング
- `screen` - レンダリングされた DOM を検索

**よく使うクエリ:**
- `getByText` - テキストで検索
- `getByRole` - ロール（役割）で検索
- `getByPlaceholderText` - placeholder で検索
- `getByTestId` - data-testid で検索

</div>
</div>

---

## 4.3 クエリの種類

<div grid="~ cols-2 gap-4">
<div>

**getBy vs queryBy vs findBy:**

```tsx
// getBy - 要素がない場合はエラー
const button = screen.getByText('送信');

// queryBy - 要素がない場合は null
const error = screen.queryByText('エラー');
expect(error).toBeNull();

// findBy - 非同期で要素を待つ
const message = await screen.findByText('完了');
```

</div>
<div>

**使い分け:**

| クエリ | 要素なし | 用途 |
|--------|----------|------|
| getBy | エラー | 必ず存在する要素 |
| queryBy | null | 存在しないことを確認 |
| findBy | 待機 | 非同期で表示される要素 |

**All 付きのクエリ:**
- `getAllByText` - 複数の要素を取得
- `queryAllByRole` - 複数の要素を取得（null ではなく空配列）

</div>
</div>

---

## 4.4 ユーザーイベントのテスト

<div grid="~ cols-2 gap-4">
<div>

**user-event を使ったテスト:**

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Counter } from './Counter';

describe('Counter', () => {
  it('クリックでカウントが増える', async () => {
    const user = userEvent.setup();
    render(<Counter />);

    const button = screen.getByRole('button');
    await user.click(button);

    expect(screen.getByText('1')).toBeInTheDocument();
  });
});
```

</div>
<div>

**user-event の主なメソッド:**

```tsx
const user = userEvent.setup();

// クリック
await user.click(element);

// ダブルクリック
await user.dblClick(element);

// テキスト入力
await user.type(input, 'Hello');

// テキストをクリア
await user.clear(input);

// キーボード操作
await user.keyboard('{Enter}');

// ホバー
await user.hover(element);
```

</div>
</div>

---

## 4.5 フォームのテスト

<div grid="~ cols-2 gap-4">
<div>

**入力フォームのテスト例:**

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { LoginForm } from './LoginForm';

describe('LoginForm', () => {
  it('入力値が反映される', async () => {
    const user = userEvent.setup();
    render(<LoginForm />);

    const input = screen.getByPlaceholderText('メール');
    await user.type(input, 'test@example.com');

    expect(input).toHaveValue('test@example.com');
  });
});
```

</div>
<div>

**フォーム送信のテスト:**

```tsx
it('送信ボタンでonSubmitが呼ばれる', async () => {
  const user = userEvent.setup();
  const handleSubmit = vi.fn();

  render(<LoginForm onSubmit={handleSubmit} />);

  await user.type(
    screen.getByPlaceholderText('メール'),
    'test@example.com'
  );
  await user.click(screen.getByRole('button'));

  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@example.com',
  });
});
```

</div>
</div>

---

# 5. チャットアプリのテスト実践

## 5.1 テストファイルの構成

```
src/
├── components/
│   ├── MessageItem.tsx
│   ├── MessageItem.test.tsx    ← コンポーネントと同じ場所に
│   ├── SearchBar.tsx
│   └── SearchBar.test.tsx
├── utils/
│   ├── validator.ts
│   ├── validator.test.ts       ← ユーティリティと同じ場所に
│   ├── dateFormatter.ts
│   └── dateFormatter.test.ts
└── test/
    └── setup.ts                ← セットアップファイル
```

テストファイルは対象ファイルと同じディレクトリに配置するのが一般的です.

---

## 5.2 dateFormatter のテスト

<div grid="~ cols-2 gap-4">
<div>

**テスト対象:**

```ts
// src/utils/dateFormatter.ts
export const formatRelativeTime = (date: string): string => {
  const now = new Date();
  const messageDate = new Date(date);
  const diffMs = now.getTime() - messageDate.getTime();
  const diffMins = Math.floor(diffMs / 60000);

  if (diffMins < 1) return 'たった今';
  if (diffMins < 60) return `${diffMins}分前`;

  const diffHours = Math.floor(diffMins / 60);
  if (diffHours < 24) return `${diffHours}時間前`;

  const diffDays = Math.floor(diffHours / 24);
  if (diffDays < 7) return `${diffDays}日前`;

  return messageDate.toLocaleDateString('ja-JP');
};
```

</div>
<div>

**テストコード:**

```ts
// src/utils/dateFormatter.test.ts
import { describe, it, expect, vi } from 'vitest';
import { formatRelativeTime } from './dateFormatter';

describe('formatRelativeTime', () => {
  it('1分未満は「たった今」を返す', () => {
    const now = new Date();
    const result = formatRelativeTime(now.toISOString());
    expect(result).toBe('たった今');
  });

  it('5分前は「5分前」を返す', () => {
    const fiveMinutesAgo = new Date(
      Date.now() - 5 * 60 * 1000
    );
    const result = formatRelativeTime(
      fiveMinutesAgo.toISOString()
    );
    expect(result).toBe('5分前');
  });
});
```

</div>
</div>

---

## 5.3 dateFormatter のテスト（続き）

<div grid="~ cols-2 gap-4">
<div>

**時間と日付のテスト:**

```ts
it('2時間前は「2時間前」を返す', () => {
  const twoHoursAgo = new Date(
    Date.now() - 2 * 60 * 60 * 1000
  );
  const result = formatRelativeTime(
    twoHoursAgo.toISOString()
  );
  expect(result).toBe('2時間前');
});

it('3日前は「3日前」を返す', () => {
  const threeDaysAgo = new Date(
    Date.now() - 3 * 24 * 60 * 60 * 1000
  );
  const result = formatRelativeTime(
    threeDaysAgo.toISOString()
  );
  expect(result).toBe('3日前');
});
```

</div>
<div>

**1週間以上前のテスト:**

```ts
it('7日以上前は日付を返す', () => {
  const tenDaysAgo = new Date(
    Date.now() - 10 * 24 * 60 * 60 * 1000
  );
  const result = formatRelativeTime(
    tenDaysAgo.toISOString()
  );

  // 日付形式であることを確認
  expect(result).toMatch(/\d{4}\/\d{1,2}\/\d{1,2}/);
});
```

**ポイント:**
- 境界値（1分, 60分, 24時間, 7日）をテスト
- 正規表現で日付形式を確認

</div>
</div>

---

## 5.4 HighlightText のテスト

<div grid="~ cols-2 gap-4">
<div>

**テスト対象:**

```tsx
// src/components/HighlightText.tsx
import { Box } from '@mui/material';

type HighlightTextProps = {
  text: string;
  searchTerm: string;
};

export const HighlightText = ({
  text,
  searchTerm
}: HighlightTextProps) => {
  if (!searchTerm.trim()) {
    return <>{text}</>;
  }
  // ハイライト処理...
};
```

</div>
<div>

**テストコード:**

```tsx
// src/components/HighlightText.test.tsx
import { render, screen } from '@testing-library/react';
import { HighlightText } from './HighlightText';

describe('HighlightText', () => {
  it('検索語がない場合はテキストをそのまま表示', () => {
    render(
      <HighlightText text="Hello World" searchTerm="" />
    );
    expect(screen.getByText('Hello World'))
      .toBeInTheDocument();
  });

  it('検索語がある場合はハイライト', () => {
    render(
      <HighlightText text="Hello World" searchTerm="World" />
    );
    expect(screen.getByText('World'))
      .toBeInTheDocument();
  });
});
```

</div>
</div>

---

## 5.5 SearchBar のテスト

<div grid="~ cols-2 gap-4">
<div>

**テストコード:**

```tsx
// src/components/SearchBar.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { vi } from 'vitest';
import { SearchBar } from './SearchBar';

const mockColors = {
  primary: '#1976d2',
  secondary: '#9c27b0',
  surface: '#ffffff',
  gradient: 'linear-gradient(...)',
  gradientHover: 'linear-gradient(...)',
  background: '#f5f5f5',
};
```

</div>
<div>

**テストケース:**

```tsx
describe('SearchBar', () => {
  it('入力フィールドが表示される', () => {
    render(
      <SearchBar
        searchTerm=""
        colors={mockColors}
        onSearchChange={() => {}}
      />
    );

    expect(screen.getByPlaceholderText('メッセージを検索...'))
      .toBeInTheDocument();
  });
});
```

</div>
</div>

---

## 5.6 SearchBar のテスト（続き）

<div grid="~ cols-2 gap-4">
<div>

**入力テスト:**

```tsx
it('入力するとonSearchChangeが呼ばれる', async () => {
  const user = userEvent.setup();
  const handleChange = vi.fn();

  render(
    <SearchBar
      searchTerm=""
      colors={mockColors}
      onSearchChange={handleChange}
    />
  );

  const input = screen.getByPlaceholderText(
    'メッセージを検索...'
  );
  await user.type(input, 'test');

  expect(handleChange).toHaveBeenCalled();
});
```

</div>
<div>

**クリアボタンのテスト:**

```tsx
it('検索語があるとクリアボタンが表示される', () => {
  render(
    <SearchBar
      searchTerm="test"
      colors={mockColors}
      onSearchChange={() => {}}
    />
  );

  // クリアボタン（×アイコン）を確認
  expect(screen.getByRole('button')).toBeInTheDocument();
});

it('検索語がないとクリアボタンは非表示', () => {
  render(
    <SearchBar
      searchTerm=""
      colors={mockColors}
      onSearchChange={() => {}}
    />
  );

  expect(screen.queryByRole('button')).toBeNull();
});
```

</div>
</div>

---

## 5.7 モックの活用

<div grid="~ cols-2 gap-4">
<div>

**vi.fn() でモック関数を作成:**

```tsx
import { vi } from 'vitest';

// モック関数を作成
const mockFn = vi.fn();

// 戻り値を設定
const mockFn = vi.fn(() => 'return value');

// 特定の引数で呼ばれたか確認
expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2');

// 呼び出し回数を確認
expect(mockFn).toHaveBeenCalledTimes(2);
```

</div>
<div>

**モジュールのモック:**

```tsx
// 外部モジュールをモック
vi.mock('uuid', () => ({
  v4: () => 'mocked-uuid-1234',
}));

// IndexedDB をモック（Dexie）
vi.mock('dexie', () => ({
  default: class MockDexie {
    messages = {
      add: vi.fn(),
      delete: vi.fn(),
      toArray: vi.fn(() => Promise.resolve([])),
    };
  },
}));
```

</div>
</div>

---

# 6. カバレッジの確認

## 6.1 カバレッジとは

<div grid="~ cols-2 gap-4">
<div>

**コードカバレッジ**は, テストがコードのどれだけをカバーしているかを示す指標です.

**4つの指標:**
- **Statements** - 文のカバレッジ
- **Branches** - 分岐のカバレッジ
- **Functions** - 関数のカバレッジ
- **Lines** - 行のカバレッジ

</div>
<div>

**例:**

```ts
function example(x: number) {  // ← Functions
  if (x > 0) {                 // ← Branches (分岐1)
    return 'positive';         // ← Statements, Lines
  } else {                     // ← Branches (分岐2)
    return 'non-positive';     // ← Statements, Lines
  }
}

// テストで x > 0 のケースしかテストしない場合:
// - Branches: 50% (2分岐中1分岐のみ)
```

</div>
</div>

---

## 6.2 カバレッジの設定

<div grid="~ cols-2 gap-4">
<div>

**カバレッジプロバイダをインストール:**

```bash
npm install -D @vitest/coverage-v8
```

**vite.config.ts に設定を追加:**

```ts
export default defineConfig({
  // ...
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html'],
      exclude: ['node_modules/', 'src/test/'],
    },
  },
});
```

</div>
<div>

**設定の説明:**

- `provider: 'v8'` - V8 エンジンのカバレッジを使用
- `reporter` - 出力形式
  - `text` - ターミナルに表示
  - `html` - HTML レポートを生成
- `exclude` - カバレッジから除外するファイル

</div>
</div>

---

## 6.3 カバレッジの実行

```bash
npm run test:coverage
```

**ターミナル出力例:**

```
 % Coverage report from v8
-----------------------|---------|----------|---------|---------|
File                   | % Stmts | % Branch | % Funcs | % Lines |
-----------------------|---------|----------|---------|---------|
All files              |   78.26 |    66.67 |   85.71 |   78.26 |
 utils                 |     100 |      100 |     100 |     100 |
  dateFormatter.ts     |     100 |      100 |     100 |     100 |
  validator.ts         |     100 |      100 |     100 |     100 |
 components            |   65.22 |       50 |   66.67 |   65.22 |
  HighlightText.tsx    |     100 |      100 |     100 |     100 |
  SearchBar.tsx        |   45.45 |    33.33 |      50 |   45.45 |
-----------------------|---------|----------|---------|---------|
```

---

## 6.4 HTML レポートの確認

<div grid="~ cols-2 gap-4">
<div>

**HTML レポートを開く:**

```bash
# coverage/index.html をブラウザで開く
open coverage/index.html
```

**HTML レポートの特徴:**
- ファイルごとの詳細を確認できる
- カバーされていない行がハイライト
- ドリルダウンして詳細を確認

</div>
<div>

**レポートの見方:**

緑色: テストでカバーされている
赤色: テストでカバーされていない
黄色: 部分的にカバー（一部の分岐のみ）

**カバレッジ向上のヒント:**
1. 赤い行を確認
2. その行を通るテストケースを追加
3. 分岐を網羅するテストを書く

</div>
</div>

---

## 6.5 カバレッジの目標値

<div grid="~ cols-2 gap-4">
<div>

**一般的な目標値:**

| 指標 | 目標値 |
|------|--------|
| Statements | 80%以上 |
| Branches | 70%以上 |
| Functions | 80%以上 |
| Lines | 80%以上 |

**注意点:**
- 100%を目指す必要はない
- 重要なビジネスロジックを優先
- テストしにくいコードは設計を見直す

</div>
<div>

**カバレッジしきい値の設定:**

```ts
// vite.config.ts
test: {
  coverage: {
    provider: 'v8',
    reporter: ['text', 'html'],
    thresholds: {
      statements: 80,
      branches: 70,
      functions: 80,
      lines: 80,
    },
  },
}
```

しきい値を下回るとテストが失敗します.

</div>
</div>

---

# 7. まとめと次のステップ

## 7.1 今回学んだこと

<v-clicks>

- **自動テストの必要性** - 安心してコードを変更するための保険
- **テストの種類** - ユニット, 統合, E2E, VRT
- **Vitest のセットアップ** - Vite プロジェクトに最適
- **Testing Library の使い方** - ユーザー視点でテスト
- **ユーティリティ関数のテスト** - 純粋関数は書きやすい
- **コンポーネントのテスト** - render, screen, userEvent
- **カバレッジ** - テストの網羅性を数値化

</v-clicks>

---

## 7.2 テストを書くコツ

<div grid="~ cols-2 gap-4">
<div>

**良いテストの特徴:**

- 読みやすい（テスト名でわかる）
- 独立している（他のテストに依存しない）
- 繰り返し実行できる（同じ結果になる）
- 速い（待ち時間が短い）

**テストを書くタイミング:**

- 新機能を追加するとき
- バグを修正するとき
- リファクタリングの前

</div>
<div>

**テスト駆動開発（TDD）:**

```
1. テストを書く（Red）
      ↓
2. テストが通る最小のコードを書く（Green）
      ↓
3. コードを整理する（Refactor）
      ↓
   1に戻る
```

まずは「既存コードにテストを追加する」ことから始めましょう!

</div>
</div>

---

## 7.3 次のステップ

<div grid="~ cols-2 gap-4">
<div>

**さらに学ぶには:**

- **MSW** - API モックの高度な手法
- **React Testing Library ドキュメント**
- **Vitest ドキュメント**
- **Playwright / Cypress** - E2E テスト
- **Storybook + Chromatic** - VRT

</div>
<div>

**今日からできること:**

1. チャットアプリにテストを追加
2. カバレッジ 80% を目指す
3. CI/CD でテストを自動実行

テストは最初は面倒に感じますが, 長期的にはコードの品質と開発速度を向上させます.

</div>
</div>

---
layout: section
---

# お疲れさまでした!

## テストで安心できるコードベースを作りましょう
