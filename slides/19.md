---
theme: default
background: https://picsum.photos/1920/1080
class: text-center
highlighter: shiki
lineNumbers: false
info: |
  ## TypeScript + React ハンズオン講座
  第19回：チャットアプリ開発（高度な機能追加編）
fonts:
  sans: "Josefin Sans"
  serif: "Noto Sans JP"
  mono: "Fira Code"

drawings:
  persist: false
transition: slide-left
title: TypeScript/React 入門講義
---

# TypeScript + React<br>ハンズオン講座

## 第19回：チャットアプリ開発<br>高度な機能追加編

<div class="pt-12">
  <span @click="$slidev.nav.next" class="px-2 py-1 rounded cursor-pointer" hover="bg-white bg-opacity-10">
    Press Space for next page <carbon:arrow-right class="inline"/>
  </span>
</div>

<div class="abs-br m-6 flex gap-2">
  <button @click="$slidev.nav.openInEditor()" title="Open in Editor" class="text-xl slidev-icon-btn opacity-50 !border-none !hover:text-white">
    <carbon:edit />
  </button>
</div>

<style>
h1 {
  background-color: #fff;
  background-image: none;
}
</style>

---
layout: section
---

# 出席確認✋️

---
layout: default
---

# 本日の内容

<Toc minDepth="2" maxDepth="2" />

<style>
h2 {
  margin: 1rem 0;
}
</style>

## 👉️ チャットアプリをさらに便利にしよう！

---
layout: section
---

# チャットアプリの高度な機能追加

---

# 目次

## 1. メッセージ編集機能
## 2. 検索機能の追加
## 3. ユーザー設定機能
## 4. パフォーマンス最適化

※今回は TypeScript でより実用的なチャット機能を追加します．

<style>
h2 {
  margin-bottom: .5rem;
}
</style>

---

# 2. メッセージ編集機能

## 2.1 編集機能の必要性

削除だけでなく，編集機能も追加しましょう：

📝 **ユーザーのニーズ：**
- タイポの修正
- 追加情報の記入
- 誤った情報の訂正

📝 **技術的な検討点：**
- 編集中の状態管理
- データベースの更新処理
- 編集履歴の保持（今回は省略）

---

## 2.2 編集機能の実装

メッセージ編集機能を実装します：

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/components/MessageItem.tsx
import EditIcon from '@mui/icons-material/Edit';
import CheckIcon from '@mui/icons-material/Check';
import CancelIcon from '@mui/icons-material/Cancel';

type MessageItemProps = {
  message: Message;
  onDelete: (id: number) => void;
  onEdit: (id: number, newText: string) => void;
};

export const MessageItem = ({ message, onDelete, onEdit }: MessageItemProps) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(message.text);

  const handleEdit = () => {
    setIsEditing(true);
    setEditText(message.text);
  };

  const handleSave = () => {
    if (editText.trim() && message.id) {
      onEdit(message.id, editText.trim());
      setIsEditing(false);
    }
  };

  const handleCancel = () => {
    setEditText(message.text);
    setIsEditing(false);
  };
```

</div>
<div>

```tsx
  return (
    <Box sx={{ position: 'relative' }}>
      {/* 編集・削除ボタン */}
      {!isEditing && (
        <Box className="action-buttons" sx={{
          position: 'absolute',
          top: 8,
          right: 8,
          visibility: 'hidden',
          display: 'flex',
          gap: 1
        }}>
          <IconButton onClick={handleEdit} size="small">
            <EditIcon fontSize="small" />
          </IconButton>
          <IconButton onClick={handleDelete} size="small">
            <DeleteIcon fontSize="small" />
          </IconButton>
        </Box>
      )}

      {/* 編集中の保存・キャンセルボタン */}
      {isEditing && (
        <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
          <IconButton onClick={handleSave} size="small" color="primary">
            <CheckIcon />
          </IconButton>
          <IconButton onClick={handleCancel} size="small">
            <CancelIcon />
          </IconButton>
        </Box>
      )}
    </Box>
  );
};
```

</div>
</div>

---

## 2.3 データベース更新処理

編集内容をデータベースに反映します：

<div grid="~ cols-2 gap-4">
<div>

```tsx
// App.tsx
const editMessage = async (id: number, newText: string): Promise<void> => {
  if (!newText.trim()) {
    alert('メッセージを入力してください');
    return;
  }

  try {
    const updatedAt = new Date();

    await db.messages.update(id, {
      text: newText,
      updatedAt
    });

    setMessages(prev => prev.map(msg =>
      msg.id === id
        ? { ...msg, text: newText, updatedAt }
        : msg
    ));
  } catch (error) {
    console.error('編集に失敗しました:', error);
    alert('編集に失敗しました．もう一度試してください．');
  }
};
```

</div>
<div>

```tsx
// Message 型の更新
export type Message = {
  id?: number;
  text: string;
  image?: string;
  date: string;
  createdAt: Date;
  updatedAt?: Date;
};

// 編集済みマークの表示
{message.updatedAt && (
  <Typography
    variant="caption"
    sx={{
      color: 'text.secondary',
      fontSize: '0.7rem',
      fontStyle: 'italic'
    }}
  >
    (編集済み)
  </Typography>
)}
```

📝 **型安全性：**

- `updatedAt` は optional として定義
- 編集機能で必要な型のみ追加

</div>
</div>

---

# 3. 検索機能の追加

## 3.1 検索機能の必要性

メッセージが増えてくると検索機能が必要になります：

📝 **ユーザーのニーズ：**
- 過去のメッセージを素早く見つけたい
- 特定のキーワードで絞り込みたい
- 日付で絞り込みたい

📝 **実装方針：**
- リアルタイム検索
- 大文字小文字を区別しない
- 検索結果のハイライト

---

## 3.2 検索 UI の実装

検索機能の UI を追加します：

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/components/SearchBar.tsx
import { TextField, InputAdornment } from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import ClearIcon from '@mui/icons-material/Clear';

type SearchBarProps = {
  searchTerm: string;
  onSearchChange: (term: string) => void;
};

export const SearchBar = ({ searchTerm, onSearchChange }: SearchBarProps) => {
  const handleClear = () => {
    onSearchChange('');
  };

  return (
    <TextField
      fullWidth
      placeholder="メッセージを検索..."
      value={searchTerm}
      onChange={(e) => onSearchChange(e.target.value)}
      size="small"
      sx={{ mb: 2 }}
```

</div>
<div>

```tsx
      InputProps={{
        startAdornment: (
          <InputAdornment position="start">
            <SearchIcon />
          </InputAdornment>
        ),
        endAdornment: searchTerm && (
          <InputAdornment position="end">
            <IconButton onClick={handleClear} size="small">
              <ClearIcon />
            </IconButton>
          </InputAdornment>
        ),
      }}
    />
  );
};
```

</div>
</div>

<div grid="~ cols-2 gap-4">
<div>

```tsx
// App.tsx での状態管理
const [searchTerm, setSearchTerm] = useState('');

// 検索フィルター関数
const filteredMessages = useMemo(() => {
  if (!searchTerm.trim()) {
    return messages;
  }

  return messages.filter(message =>
    message.text.toLowerCase().includes(searchTerm.toLowerCase())
  );
}, [messages, searchTerm]);

// コンポーネント内で使用
<SearchBar
  searchTerm={searchTerm}
  onSearchChange={setSearchTerm}
/>

{filteredMessages.map((message) => (
  <MessageItem key={message.id} message={message} />
))}
```

📝 **パフォーマンス：**

- `useMemo` で不要な再計算を防止
- 検索処理の最適化

</div>
</div>

---

## 3.3 検索結果のハイライト

検索キーワードをハイライト表示します：

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/utils/textHighlight.tsx
type HighlightTextProps = {
  text: string;
  searchTerm: string;
};

export const HighlightText = ({ text, searchTerm }: HighlightTextProps) => {
  if (!searchTerm.trim()) {
    return <>{text}</>;
  }

  const regex = new RegExp(`(${searchTerm})`, 'gi');
  const parts = text.split(regex);

  return (
    <>
      {parts.map((part, index) =>
        regex.test(part) ? (
          <Box
            key={index}
            component="span"
            sx={{
              backgroundColor: 'yellow',
              fontWeight: 'bold',
              padding: '2px 4px',
              borderRadius: '4px'
            }}
          >
            {part}
          </Box>
        ) : (
          part
        )
      )}
    </>
  );
};
```

</div>
<div>

```tsx
// MessageItem.tsx での使用
import { HighlightText } from '../utils/textHighlight';

type MessageItemProps = {
  message: Message;
  searchTerm: string;
  onDelete: (id: number) => void;
  onEdit: (id: number, newText: string) => void;
};

// メッセージテキストの表示部分
<Typography variant="body1">
  <HighlightText
    text={message.text}
    searchTerm={searchTerm}
  />
</Typography>
```

📝 **ハイライト機能：**

- 正規表現で大文字小文字を区別しない検索
- 黄色いマーカーでキーワードを強調
- React Fragment で自然なテキスト表示

</div>
</div>

---

# 4. ユーザー設定機能

## 4.1 設定機能の追加

ユーザーが好みに応じてアプリをカスタマイズできる設定を追加します：

📝 **設定項目：**
- ダークモード切り替え
- フォントサイズ変更
- 通知設定

📝 **実装方針：**
- Material-UI のテーマシステム活用
- localStorage での設定保存
- TypeScript での型安全な設定管理

---

## 4.2 設定の型定義と状態管理

設定機能の基盤を作成します：

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/types/settings.ts
export type AppSettings = {
  theme: 'light' | 'dark';
  fontSize: 'small' | 'medium' | 'large';
  notifications: boolean;
};

export const defaultSettings: AppSettings = {
  theme: 'light',
  fontSize: 'medium',
  notifications: true
};

// src/hooks/useSettings.ts
import { useState, useEffect } from 'react';

export const useSettings = () => {
  const [settings, setSettings] = useState<AppSettings>(defaultSettings);

  useEffect(() => {
    const saved = localStorage.getItem('chatAppSettings');
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as AppSettings;
        setSettings(parsed);
      } catch (error) {
        console.error('設定の読み込みに失敗しました:', error);
      }
    }
  }, []);
```

</div>
<div>

```tsx
  const updateSettings = (newSettings: Partial<AppSettings>) => {
    const updated = { ...settings, ...newSettings };
    setSettings(updated);
    localStorage.setItem('chatAppSettings', JSON.stringify(updated));
  };

  return {
    settings,
    updateSettings
  };
};

// App.tsx での使用
const { settings, updateSettings } = useSettings();
```

📝 **型安全性：**

- 設定値の型を厳密に定義
- `Partial<AppSettings>` で部分更新を型安全に
- localStorage との連携も型チェック

</div>
</div>

---

## 4.3 ダークモードの実装

Material-UI テーマを使ったダークモード切り替え：

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/theme/theme.ts
import { createTheme } from '@mui/material/styles';

export const getTheme = (mode: 'light' | 'dark', fontSize: 'small' | 'medium' | 'large') => {
  const fontSizeMap = {
    small: 12,
    medium: 14,
    large: 16
  };

  return createTheme({
    palette: {
      mode,
      primary: {
        main: '#1976d2',
      },
      secondary: {
        main: '#dc004e',
      },
    },
    typography: {
      fontSize: fontSizeMap[fontSize],
    },
    components: {
      MuiCard: {
        styleOverrides: {
          root: {
            borderRadius: 12,
          },
        },
      },
    },
  });
};
```

</div>
<div>

```tsx
// App.tsx
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';

const App = () => {
  const { settings, updateSettings } = useSettings();
  const theme = getTheme(settings.theme, settings.fontSize);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Container maxWidth="md" sx={{ py: 4 }}>
        {/* アプリコンテンツ */}
      </Container>
    </ThemeProvider>
  );
};
```

📝 **テーマの特徴：**

- ダークモードとライトモードの自動切り替え
- フォントサイズも動的変更
- Material-UI コンポーネントのカスタマイズ

</div>
</div>

---

## 4.4 設定パネルの UI

設定を変更するための UI を作成します：

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/components/SettingsPanel.tsx
import {
  Dialog, DialogTitle, DialogContent,
  FormControl, FormLabel, RadioGroup,
  FormControlLabel, Radio, Switch
} from '@mui/material';

type SettingsPanelProps = {
  open: boolean;
  onClose: () => void;
  settings: AppSettings;
  onUpdateSettings: (settings: Partial<AppSettings>) => void;
};

export const SettingsPanel = ({
  open, onClose, settings, onUpdateSettings
}: SettingsPanelProps) => {
  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>設定</DialogTitle>
      <DialogContent>
        {/* テーマ設定 */}
        <FormControl component="fieldset" sx={{ mb: 3 }}>
          <FormLabel component="legend">テーマ</FormLabel>
          <RadioGroup
            value={settings.theme}
            onChange={(e) => onUpdateSettings({ theme: e.target.value as 'light' | 'dark' })}
          >
            <FormControlLabel value="light" control={<Radio />} label="ライト" />
            <FormControlLabel value="dark" control={<Radio />} label="ダーク" />
          </RadioGroup>
        </FormControl>
```

</div>
<div>

```tsx
        {/* フォントサイズ設定 */}
        <FormControl component="fieldset" sx={{ mb: 3 }}>
          <FormLabel component="legend">フォントサイズ</FormLabel>
          <RadioGroup
            value={settings.fontSize}
            onChange={(e) => onUpdateSettings({ fontSize: e.target.value as any })}
          >
            <FormControlLabel value="small" control={<Radio />} label="小" />
            <FormControlLabel value="medium" control={<Radio />} label="中" />
            <FormControlLabel value="large" control={<Radio />} label="大" />
          </RadioGroup>
        </FormControl>

        {/* 通知設定 */}
        <FormControlLabel
          control={
            <Switch
              checked={settings.notifications}
              onChange={(e) => onUpdateSettings({ notifications: e.target.checked })}
            />
          }
          label="通知を有効にする"
        />
      </DialogContent>
    </Dialog>
  );
};
```

</div>
</div>

---

# 5. パフォーマンス最適化

## 5.1 React.memo による最適化

不要な再レンダリングを防ぐために React.memo を活用します：

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/components/MessageItem.tsx
import { memo } from 'react';

type MessageItemProps = {
  message: Message;
  searchTerm: string;
  onDelete: (id: number) => void;
  onEdit: (id: number, newText: string) => void;
};

export const MessageItem = memo(({
  message, searchTerm, onDelete, onEdit
}: MessageItemProps) => {
  // コンポーネントの実装...
});

// カスタム比較関数（必要に応じて）
export const MessageItem = memo(MessageItemComponent, (prevProps, nextProps) => {
  return (
    prevProps.message.id === nextProps.message.id &&
    prevProps.message.text === nextProps.message.text &&
    prevProps.message.updatedAt === nextProps.message.updatedAt &&
    prevProps.searchTerm === nextProps.searchTerm
  );
});
```

</div>
<div>

```tsx
// useCallback を使った関数メモ化
const App = () => {
  const deleteMessage = useCallback(async (id: number) => {
    // 削除処理...
  }, []);

  const editMessage = useCallback(async (id: number, newText: string) => {
    // 編集処理...
  }, []);

  const handleSearchChange = useCallback((term: string) => {
    setSearchTerm(term);
  }, []);

  return (
    <>
      <SearchBar
        searchTerm={searchTerm}
        onSearchChange={handleSearchChange}
      />
      {filteredMessages.map((message) => (
        <MessageItem
          key={message.id}
          message={message}
          searchTerm={searchTerm}
          onDelete={deleteMessage}
          onEdit={editMessage}
        />
      ))}
    </>
  );
};
```

</div>
</div>

---

## 5.2 仮想化による大量データ対応

多数のメッセージを効率的に表示するための仮想化：

<div grid="~ cols-2 gap-4">
<div>

```tsx
// react-window を使った仮想化（必要に応じて）
npm install react-window @types/react-window

// src/components/VirtualizedMessageList.tsx
import { FixedSizeList as List } from 'react-window';

type VirtualizedMessageListProps = {
  messages: Message[];
  height: number;
  itemHeight: number;
  searchTerm: string;
  onDelete: (id: number) => void;
  onEdit: (id: number, text: string) => void;
};

export const VirtualizedMessageList = ({
  messages, height, itemHeight, searchTerm, onDelete, onEdit
}: VirtualizedMessageListProps) => {
  const renderItem = ({ index, style }: any) => (
    <div style={style}>
      <MessageItem
        message={messages[index]}
        searchTerm={searchTerm}
        onDelete={onDelete}
        onEdit={onEdit}
      />
    </div>
  );
```

</div>
<div>

```tsx
  return (
    <List
      height={height}
      itemCount={messages.length}
      itemSize={itemHeight}
      itemData={messages}
    >
      {renderItem}
    </List>
  );
};

// 使用例（大量データがある場合のみ）
{filteredMessages.length > 100 ? (
  <VirtualizedMessageList
    messages={filteredMessages}
    height={400}
    itemHeight={120}
    searchTerm={searchTerm}
    onDelete={deleteMessage}
    onEdit={editMessage}
  />
) : (
  filteredMessages.map((message) => (
    <MessageItem key={message.id} {...props} />
  ))
)}
```

📝 **仮想化の効果：**

- 1000件以上のメッセージでも滑らかな動作
- メモリ使用量の削減
- スクロールパフォーマンスの向上

</div>
</div>

---

# 6. 動作確認とまとめ

## 6.1 機能テスト

実装した全機能をテストしましょう：

✅ **削除機能：**
- メッセージの個別削除
- 確認ダイアログの動作
- データベースからの完全削除

✅ **編集機能：**
- メッセージテキストの編集
- 編集済みマークの表示
- データベース更新の確認

✅ **検索機能：**
- リアルタイム検索の動作
- キーワードハイライト
- 大文字小文字を区別しない検索

✅ **設定機能：**
- ダークモード切り替え
- フォントサイズ変更
- 設定の永続化

---

## 6.2 次回への準備

最終回に向けてのチェックポイント：

📝 **確認事項：**
- 全ての TypeScript エラーが解消されている
- ESLint の警告がない
- パフォーマンスが良好
- ユーザビリティに問題がない

📝 **最終回の内容予告：**
- デザインの完成度向上
- アニメーションとトランジション
- デプロイの準備
- 総復習とまとめ

---

# 7. 今日の宿題 📚

1. **今日実装した機能をいろいろ試してみる**
   - 削除・編集機能の動作確認
   - 検索機能でメッセージを探してみる
   - 設定を変更してみる

2. **React のパフォーマンス最適化について調べる**
   - React.memo の使い方
   - useCallback と useMemo の違い
   - 仮想化ライブラリの種類

3. **Material-UI のテーマシステムを学習する**
   - カスタムテーマの作成方法
   - コンポーネントスタイルのオーバーライド

4. **TypeScript の高度な型について学ぶ**
   - Union Types と Intersection Types
   - Conditional Types の基本

---
layout: section
---

# お疲れさまでした！ 🎉

## 次回で TypeScript チャットアプリ完成です！