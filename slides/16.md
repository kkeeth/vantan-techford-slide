---
theme: default
background: https://picsum.photos/1920/1080
class: text-center
highlighter: shiki
lineNumbers: true
info: |
  ## TypeScript + React ハンズオン講座
  第16回：チャットアプリ開発（メッセージ投稿機能編）
fonts:
  sans: "Josefin Sans"
  serif: "Noto Sans JP"
  mono: "Fira Code"

drawings:
  persist: false
transition: slide-left
title: TypeScript/React 入門講義
---

# TypeScript + React<br>ハンズオン講座

## 第16回：チャットアプリ開発<br>メッセージ投稿機能編

<div class="pt-12">
  <span @click="$slidev.nav.next" class="px-2 py-1 rounded cursor-pointer" hover="bg-white bg-opacity-10">
    Press Space for next page <carbon:arrow-right class="inline"/>
  </span>
</div>

<div class="abs-br m-6 flex gap-2">
  <button @click="$slidev.nav.openInEditor()" title="Open in Editor" class="text-xl slidev-icon-btn opacity-50 !border-none !hover:text-white">
    <carbon:edit />
  </button>
</div>

<style>
h1 {
  background-color: #fff;
  background-image: none;
}
</style>

---
layout: section
---

# 出席確認✋️

---
layout: default
---

# 本日の内容

<Toc minDepth="2" maxDepth="2" />

<style>
h2 {
  margin: 1rem 0;
}
</style>

## 👉️ TypeScript でメッセージ投稿機能を実装しよう！

---
layout: section
---

# メッセージ投稿機能の実装

---

# 目次

## 1. TypeScript での state 管理と型安全性
## 2. フォーム状態の実装とイベントハンドラ
## 3. メッセージ投稿処理の実装
## 4. バリデーションと UX 改善

※ TypeScript の型安全性を活用してバグの少ないコードを書きます．

<style>
h2 {
  margin-bottom: .5rem;
}
</style>

---

# 1. TypeScript での state 管理と型安全性

## 1.1 Message 型の定義とインポート

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/App.tsx に追加
import { useState, FormEvent, ChangeEvent } from 'react';
import type { Message } from './types';

const App = () => {
  // テキスト入力の状態管理
  const [text, setText] = useState<string>('');

  // メッセージリストの状態管理
  const [messages, setMessages] = useState<Message[]>([]);

  return (
    // 既存の JSX
  );
};
```

</div>
<div>

**TypeScript の型安全性**
- `useState<string>` で文字列型を明示
- `useState<Message[]>` で配列の型を保証
- TypeScript がコンパイル時に型チェック
- 誤った型の代入を防止
- IDE の補完機能が向上

</div>
</div>

---

## 1.2 型安全なイベントハンドラの実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
const App = () => {
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);

  // 型安全なテキスト変更ハンドラ
  const handleTextChange = (
    e: ChangeEvent<HTMLTextAreaElement>
  ) => {
    setText(e.target.value);
  };

  // 型安全な投稿ハンドラ
  const handlePost = (e: FormEvent) => {
    e.preventDefault();
    // 投稿処理（次で実装）
  };
};
```

</div>
<div>

**TypeScript イベントハンドラのポイント**
- `ChangeEvent<HTMLTextAreaElement>` で要素型を明示
- `FormEvent` でフォーム送信イベントを型定義
- `e.target.value` の型が自動的に推論される
- 間違ったプロパティアクセスを防止

</div>
</div>

---

# 2. フォーム状態の実装とイベントハンドラ

## 2.1 TextField の実装と状態連携

<div grid="~ cols-2 gap-4">
<div>

```tsx
// TextField を既存の Paper 内に追加
<TextField
  label="今の気分はいかがでしょうか？"
  multiline
  fullWidth
  rows={4}
  variant="outlined"
  value={text}
  onChange={handleTextChange}
  sx={{
    '& .MuiOutlinedInput-root': {
      borderRadius: 2,
      backgroundColor: 'rgba(255, 255, 255, 0.8)',
      backdropFilter: 'blur(10px)',
      '&:hover fieldset': {
        borderColor: colors.primary,
      },
      '&.Mui-focused fieldset': {
        borderColor: colors.primary,
      },
    },
  }}
/>
```

</div>
<div>

**実装のポイント**
- `value={text}` で React の制御されたコンポーネント
- `onChange={handleTextChange}` で型安全な状態更新
- Material-UI の sx prop でスタイリング
- `backdropFilter` でガラスモーフィズム効果
- ホバーとフォーカス時のカラー変更

</div>
</div>

---

## 2.2 送信ボタンの実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
import { Send as SendIcon } from '@mui/icons-material';

// TextField の下に追加
<Stack direction="row" spacing={2} sx={{ mt: 2 }}>
  <Button
    variant="contained"
    endIcon={<SendIcon />}
    onClick={handlePost}
    disabled={!text.trim()}
    sx={{
      height: 48,
      borderRadius: 2,
      background: text.trim()
        ? colors.gradient
        : undefined,
      '&:hover': {
        background: text.trim()
          ? colors.gradientHover
          : undefined,
      },
    }}
  >
    送信
  </Button>
</Stack>
```

</div>
<div>

**実装のポイント**
- `disabled={!text.trim()}` で空文字時は無効化
- `text.trim()` で空白のみの入力を除外
- 条件分岐でボタンの見た目を動的変更
- グラデーション背景で視覚的フィードバック
- Material-UI のアイコンを使用

</div>
</div>

---

# 3. メッセージ投稿処理の実装

## 3.1 投稿処理の基本実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
const handlePost = (e: FormEvent) => {
  e.preventDefault();

  // 空文字チェック
  if (!text.trim()) {
    return;
  }

  // 新しいメッセージオブジェクトを作成
  const newMessage: Message = {
    id: Date.now(),
    text: text.trim(),
    date: new Date().toLocaleString(),
  };

  // メッセージリストに追加（先頭に挿入）
  setMessages(prevMessages =>
    [newMessage, ...prevMessages]
  );

  // 入力フィールドをクリア
  setText('');
};
```

</div>
<div>

**実装のポイント**
- `e.preventDefault()` でフォーム送信を防止
- `Message` 型に準拠したオブジェクト作成
- `Date.now()` で簡易 ID 生成
- `setMessages` の関数型更新で安全な状態更新
- 配列のスプレッド構文で新しいメッセージを先頭追加

</div>
</div>

---

## 3.2 キーボードショートカットの実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
import { KeyboardEvent } from 'react';

const handleKeyDown = (
  e: KeyboardEvent<HTMLTextAreaElement>
) => {
  // Ctrl + Enter で送信
  if (e.key === 'Enter' && e.ctrlKey) {
    handlePost(e as any);
  }
};

// TextField に追加
<TextField
  // 既存のプロパティ...
  onKeyDown={handleKeyDown}
/>
```

</div>
<div>

**実装のポイント**
- `KeyboardEvent<HTMLTextAreaElement>` で型安全
- `e.key === 'Enter'` でキー判定
- `e.ctrlKey` で修飾キー判定
- `e as any` で型キャストが必要な場面も
- UX 向上のためのショートカット機能

</div>
</div>

---

# 4. バリデーションと UX 改善

## 4.1 文字数制限の実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
const MAX_MESSAGE_LENGTH = 500;

const handleTextChange = (
  e: ChangeEvent<HTMLTextAreaElement>
) => {
  const newText = e.target.value;

  // 文字数制限チェック
  if (newText.length <= MAX_MESSAGE_LENGTH) {
    setText(newText);
  }
};

// TextField に追加
<TextField
  // 既存のプロパティ...
  error={text.length > MAX_MESSAGE_LENGTH * 0.9}
  helperText={`${text.length}/${MAX_MESSAGE_LENGTH}`}
/>
```

</div>
<div>

**実装のポイント**
- `MAX_MESSAGE_LENGTH` 定数で制限値を管理
- 90% を超えた時点で警告表示
- `helperText` で現在の文字数を表示
- `error` プロパティで視覚的フィードバック
- 制限を超えた入力は受け付けない

</div>
</div>

---

## 4.2 バリデーション関数の実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
type ValidationResult = {
  isValid: boolean;
  message?: string;
};

const validateMessage = (
  text: string
): ValidationResult => {
  if (!text.trim()) {
    return {
      isValid: false,
      message: 'メッセージを入力してください',
    };
  }

  if (text.length > MAX_MESSAGE_LENGTH) {
    return {
      isValid: false,
      message: `${MAX_MESSAGE_LENGTH}文字以内で入力してください`,
    };
  }

  return { isValid: true };
};
```

</div>
<div>

**TypeScript の型安全性**
- `ValidationResult` 型でレスポンス構造を定義
- 戻り値の型を明示的に指定
- オプショナルプロパティ `message?` を使用
- 関数の責務を明確に分離
- テストしやすい純粋関数として実装

</div>
</div>

---

## 4.3 ローディング状態の実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
const App = () => {
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isPosting, setIsPosting] = useState<boolean>(false);

  const handlePost = async (e: FormEvent) => {
    e.preventDefault();

    const validation = validateMessage(text);
    if (!validation.isValid) {
      alert(validation.message);
      return;
    }

    setIsPosting(true);

    try {
      // 投稿処理をシミュレート
      await new Promise(resolve =>
        setTimeout(resolve, 500)
      );

      const newMessage: Message = {
        id: Date.now(),
        text: text.trim(),
        date: new Date().toLocaleString(),
      };

      setMessages(prev => [newMessage, ...prev]);
      setText('');
    } finally {
      setIsPosting(false);
    }
  };
```

</div>
<div>

**非同期処理と状態管理**
- `async/await` で非同期処理を実装
- `isPosting` 状態でローディング管理
- `try/finally` で確実な状態リセット
- `setTimeout` で投稿処理をシミュレート
- ユーザーに処理中であることを明示

</div>
</div>

---

## 4.4 送信ボタンの状態反映

<div grid="~ cols-2 gap-4">
<div>

```tsx
<Button
  variant="contained"
  endIcon={<SendIcon />}
  onClick={handlePost}
  disabled={!text.trim() || isPosting}
  sx={{
    height: 48,
    borderRadius: 2,
    background: (text.trim() && !isPosting)
      ? colors.gradient
      : undefined,
    '&:hover': {
      background: (text.trim() && !isPosting)
        ? colors.gradientHover
        : undefined,
    },
    transition: 'all 0.3s ease',
  }}
>
  {isPosting ? '送信中...' : '送信'}
</Button>
```

</div>
<div>

**UX 改善のポイント**
- `disabled` でローディング中は無効化
- ボタンテキストで状態を明示
- 条件分岐でスタイルを動的変更
- トランジション効果で滑らかなアニメーション
- ユーザーフィードバックの向上

</div>
</div>

---

# 5. デバッグと動作確認

## 5.1 開発者ツールでの状態確認

<div grid="~ cols-2 gap-4">
<div>

```tsx
// デバッグ用のログ出力
const handlePost = async (e: FormEvent) => {
  console.log('投稿開始:', { text, messages });

  e.preventDefault();

  const validation = validateMessage(text);
  console.log('バリデーション結果:', validation);

  if (!validation.isValid) {
    console.log('バリデーションエラー');
    alert(validation.message);
    return;
  }

  // 処理続行...
};
```

</div>
<div>

**デバッグのベストプラクティス**
- `console.log` で状態変化を追跡
- React DevTools で component 状態を確認
- Network タブで API 通信を監視（将来的に）
- TypeScript のコンパイルエラーを確認
- ブラウザのコンソールエラーをチェック

</div>
</div>

---

## 5.2 機能テストと確認項目

<div grid="~ cols-2 gap-4">
<div>

**テスト項目チェックリスト**

✅ テキスト入力ができる
✅ 送信ボタンで投稿できる
✅ Ctrl + Enter で投稿できる
✅ 空文字では投稿できない
✅ 文字数制限が機能している
✅ 文字数カウンターが表示される
✅ 投稿後にフィールドがクリアされる
✅ ローディング状態が表示される
✅ バリデーションエラーが表示される

</div>
<div>

**TypeScript コンパイルチェック**

```bash
# TypeScript エラーの確認
npm run typecheck

# 開発サーバーの起動
npm run dev
```

**ブラウザでの動作確認**
- コンソールエラーがないか確認
- React DevTools で状態変化を確認
- レスポンシブデザインの確認
- 各ブラウザでの動作確認

</div>
</div>

---

# 6. 次回の予告

## 6.1 次回の内容（第17回）

次回は TypeScript でメッセージ表示機能を実装します：

- TypeScript でのリスト表示とレンダリング
- メッセージカードコンポーネントの作成
- 型安全な props 渡しとコンポーネント分割
- CSS-in-JS でのスタイリング
- レスポンシブデザインの実装

<v-click>

## 6.2 今日の宿題 📚

1. 今日実装した TypeScript での投稿機能を試してみる
2. React DevTools をインストールして状態変化を確認する
3. TypeScript のイベントハンドラ型について調べる
4. バリデーション関数の拡張方法を考えてみる

</v-click>

---
layout: section
---

# お疲れさまでした！ 🎉

## 次回はメッセージ表示機能を作ります！