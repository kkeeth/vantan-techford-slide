---
theme: default
background: https://picsum.photos/1920/1080
class: text-center
highlighter: shiki
lineNumbers: true
info: |
  ## TypeScript + React ハンズオン講座
  第16回：チャットアプリ開発（メッセージ機能編）
fonts:
  sans: "Josefin Sans"
  serif: "Noto Sans JP"
  mono: "Fira Code"

drawings:
  persist: false
transition: slide-left
title: TypeScript/React 入門講義
---

# TypeScript + React<br>ハンズオン講座

## 第16回：チャットアプリ開発<br>メッセージ機能編

<div class="pt-12">
  <span @click="$slidev.nav.next" class="px-2 py-1 rounded cursor-pointer" hover="bg-white bg-opacity-10">
    Press Space for next page <carbon:arrow-right class="inline"/>
  </span>
</div>

<div class="abs-br m-6 flex gap-2">
  <button @click="$slidev.nav.openInEditor()" title="Open in Editor" class="text-xl slidev-icon-btn opacity-50 !border-none !hover:text-white">
    <carbon:edit />
  </button>
</div>

<style>
h1 {
  background-color: #fff;
  background-image: none;
}
</style>

---
layout: section
---

# 出席確認✋️

---
layout: default
---

# 本日の内容

<Toc minDepth="2" maxDepth="2" />

<style>
h2 {
  margin: 1rem 0;
}
</style>

## 👉️ TypeScript でメッセージ投稿・表示機能を実装しよう！

---
layout: section
---

# メッセージ機能の実装

---

# 目次

## 1. メッセージ投稿機能の実装
## 2. メッセージリスト表示機能の実装
## 3. 削除機能とユーザビリティ向上

※ 今回は機能を作りながら必要な型定義を追加していく実践的な流れで進めます．

<style>
h2 {
  margin-bottom: .5rem;
}
</style>

---

# 1. メッセージ投稿機能の実装

## 1.1 テキスト入力状態の追加

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/App.tsx
import { useState, FormEvent, ChangeEvent } from 'react';

const App = () => {
  // まずは文字列でテキスト状態を管理
  const [text, setText] = useState<string>('');

  const handleTextChange = (e: ChangeEvent<HTMLTextAreaElement>) => {
    setText(e.target.value);
  };

  return (
    // 既存の JSX...
  );
};
```

</div>
<div>

**実装のポイント**
- まず必要最小限の状態から開始
- `useState<string>` で型安全な文字列管理
- `ChangeEvent<HTMLTextAreaElement>` で適切なイベント型
- 実際の開発では段階的に機能を追加していく

</div>
</div>

---

## 1.2 投稿ボタンと送信処理の基本実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
const App = () => {
  const [text, setText] = useState<string>('');

  const handlePost = (e: FormEvent) => {
    e.preventDefault();

    // 空文字チェック
    if (!text.trim()) {
      return;
    }

    console.log('投稿:', text);

    // 入力フィールドをクリア
    setText('');
  };

  return (
    // TextField と Button の実装
  );
};
```

</div>
<div>

**送信処理のポイント**
- `FormEvent` で適切なフォームイベント型
- `e.preventDefault()` でページリロードを防止
- `text.trim()` で空白のみの投稿を防止
- まずは console.log で動作確認

</div>
</div>

---

## 1.3 メッセージ一覧の状態管理が必要になった時点で型定義

<div grid="~ cols-2 gap-4">
<div>

```tsx
// メッセージを保存する必要が出てきたので型定義を追加
// src/types.ts
export type Message = {
  id: number;
  text: string;
  date: string;
};

// src/App.tsx
import type { Message } from './types';

const App = () => {
  const [text, setText] = useState<string>('');
  // メッセージ一覧を管理する状態を追加
  const [messages, setMessages] = useState<Message[]>([]);

  const handlePost = (e: FormEvent) => {
    e.preventDefault();

    if (!text.trim()) return;

    // 新しいメッセージオブジェクトを作成
    const newMessage: Message = {
      id: Date.now(),
      text: text.trim(),
      date: new Date().toLocaleString(),
    };

    setMessages(prev => [newMessage, ...prev]);
    setText('');
  };
```

</div>
<div>

**型定義のタイミング**
- メッセージ一覧が必要になった時点で `Message` 型を定義
- 実際の開発フローに合わせて段階的に型を追加
- まず動作させてから型安全性を向上
- `Message[]` で配列の型も明示的に指定

</div>
</div>

---

## 1.4 バリデーション機能の追加

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 文字数制限が必要になったので追加
const MAX_MESSAGE_LENGTH = 500;

const App = () => {
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);

  const validateMessage = (message: string): string | null => {
    if (!message.trim()) {
      return 'メッセージを入力してください';
    }
    if (message.length > MAX_MESSAGE_LENGTH) {
      return `${MAX_MESSAGE_LENGTH}文字以内で入力してください`;
    }
    return null;
  };

  const handlePost = (e: FormEvent) => {
    e.preventDefault();
```

</div>
<div>

```tsx
    const error = validateMessage(text);
    if (error) {
      alert(error);
      return;
    }

    const newMessage: Message = {
      id: Date.now(),
      text: text.trim(),
      date: new Date().toLocaleString(),
    };

    setMessages(prev => [newMessage, ...prev]);
    setText('');
  };
```

</div>
<div>

**バリデーション実装**
- 機能が複雑になってきたら関数を分離
- `string | null` の戻り値型でエラーメッセージか null
- TypeScript の恩恵でエラーハンドリングが型安全
- 実用的な開発パターンを意識

</div>
</div>

---

# 2. メッセージリスト表示機能の実装

## 2.1 リスト表示に必要なコンポーネントのインポート

<div grid="~ cols-2 gap-4">
<div>

```tsx
// メッセージ表示が必要になったので追加インポート
import {
  Container,
  Typography,
  TextField,
  Stack,
  Button,
  Card,
  CardContent,
  CardActions,
  Box,
  Paper,
  Divider,
  Chip,
} from '@mui/material';
import {
  Send as SendIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';
```

</div>
<div>

**段階的なインポート**
- 最初から全部インポートせず、必要になったタイミングで追加
- `Card` 系：メッセージをカード形式で表示したくなった時
- `Chip`：日時表示をコンパクトにしたくなった時
- `DeleteIcon`：削除機能が必要になった時

</div>
</div>

---

## 2.2 基本的なメッセージリストの表示

<div grid="~ cols-2 gap-4">
<div>

```tsx
// メッセージ投稿フォームの下に追加
<Stack spacing={3} sx={{ mt: 3 }}>
  {messages.length === 0 ? (
    <Paper
      elevation={1}
      sx={{
        p: 4,
        textAlign: 'center',
        background: 'rgba(255, 255, 255, 0.7)',
        borderRadius: 3,
      }}
    >
      <Typography variant="h6" color="text.secondary">
        📝 まだメッセージがありません
      </Typography>
      <Typography variant="body2" color="text.secondary">
        上のフォームから最初のメッセージを投稿してみましょう！
      </Typography>
    </Paper>
  ) : (
```

</div>
<div>

```tsx
    messages.map((message: Message) => (
      <Card key={message.id} elevation={3}>
        <CardContent>
          <Typography variant="body1">
            {message.text}
          </Typography>
          <Typography variant="caption" color="text.secondary">
            {message.date}
          </Typography>
        </CardContent>
      </Card>
    ))
  )}
</Stack>
```

</div>
<div>

**実装のポイント**
- 空状態の表示でユーザビリティ向上
- `map` で TypeScript の型安全なリストレンダリング
- `key={message.id}` で React のパフォーマンス最適化
- まずはシンプルな表示から開始

</div>
</div>

---

## 2.3 日時表示の改善が必要になった段階で相対時間関数を追加

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 「◯分前」表示が欲しくなったので関数を追加
const formatRelativeTime = (dateString: string): string => {
  const now = new Date();
  const messageDate = new Date(dateString);
  const diffInMinutes = Math.floor(
    (now.getTime() - messageDate.getTime()) / (1000 * 60)
  );

  if (diffInMinutes < 1) return 'たった今';
  if (diffInMinutes < 60) return `${diffInMinutes}分前`;

  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) return `${diffInHours}時間前`;

  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays < 7) return `${diffInDays}日前`;

  return messageDate.toLocaleDateString('ja-JP');
};

// Chip を使った表示に変更
<Chip
  label={formatRelativeTime(message.date)}
  size="small"
  variant="outlined"
  sx={{
    height: 24,
    fontSize: '0.75rem',
    borderColor: colors.primary,
    color: colors.primary,
  }}
/>
```

</div>
<div>

**機能拡張のタイミング**
- 基本表示ができてから UX 改善
- 純粋関数として分離することで再利用性向上
- TypeScript の型注釈で戻り値を明確化
- 段階的な改善でコードの可読性を保つ

</div>
</div>

---

# 3. 削除機能とユーザビリティ向上

## 3.1 削除機能が必要になった時点で実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 削除機能が欲しくなったので追加
const handleDeleteMessage = (messageId: number): void => {
  const targetMessage = messages.find(
    (message: Message) => message.id === messageId
  );

  if (!targetMessage) {
    console.warn(`Message with id ${messageId} not found`);
    return;
  }

  const previewText = targetMessage.text.length > 20
    ? `${targetMessage.text.substring(0, 20)}...`
    : targetMessage.text;

  if (window.confirm(`「${previewText}」を削除しますか？`)) {
    setMessages(prevMessages =>
      prevMessages.filter(message => message.id !== messageId)
    );
  }
};

// CardActions を追加
<CardActions sx={{ justifyContent: 'flex-end', p: 2 }}>
  <Button
    size="small"
    color="error"
    startIcon={<DeleteIcon />}
    onClick={() => handleDeleteMessage(message.id)}
  >
    削除
  </Button>
</CardActions>
```

</div>
<div>

**削除機能のポイント**
- `find` メソッドで対象メッセージを安全に検索
- TypeScript が `undefined` の可能性をチェック
- ユーザーフレンドリーな確認ダイアログ
- `filter` で immutable な配列更新

</div>
</div>

---

## 3.2 ローディング状態が必要になった段階で追加

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 投稿中の状態管理が必要になったので追加
const App = () => {
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isPosting, setIsPosting] = useState<boolean>(false);

  const handlePost = async (e: FormEvent) => {
    e.preventDefault();

    const error = validateMessage(text);
    if (error) {
      alert(error);
      return;
    }

    setIsPosting(true);

    try {
      // 投稿処理をシミュレート
      await new Promise(resolve => setTimeout(resolve, 500));

      const newMessage: Message = {
        id: Date.now(),
        text: text.trim(),
        date: new Date().toLocaleString(),
      };

      setMessages(prev => [newMessage, ...prev]);
      setText('');
    } finally {
      setIsPosting(false);
    }
  };
```

</div>
<div>

**ローディング状態管理**
- UX 向上が必要になった段階で state 追加
- `async/await` で非同期処理を型安全に
- `try/finally` で確実な状態リセット
- ボタンの disabled 状態で二重送信防止

</div>
</div>

---

## 3.3 送信ボタンの状態反映

<div grid="~ cols-2 gap-4">
<div>

```tsx
<Button
  variant="contained"
  endIcon={<SendIcon />}
  onClick={handlePost}
  disabled={!text.trim() || isPosting}
  sx={{
    height: 48,
    borderRadius: 2,
    background: (text.trim() && !isPosting)
      ? colors.gradient
      : undefined,
    '&:hover': {
      background: (text.trim() && !isPosting)
        ? colors.gradientHover
        : undefined,
    },
  }}
>
  {isPosting ? '送信中...' : '送信'}
</Button>
```

</div>
<div>

**UX 改善のポイント**
- ボタンテキストで状態を明示
- disabled 属性で無効化
- 条件分岐でスタイルを動的変更
- TypeScript で boolean 型の安全な操作

</div>
</div>

---

# 4. レスポンシブ対応とデザイン改善

## 4.1 画面サイズに応じた調整

<div grid="~ cols-2 gap-4">
<div>

```tsx
// レスポンシブデザインが必要になったので調整
<Stack spacing={{ xs: 2, sm: 3 }} sx={{ mt: 3 }}>
  {messages.map((message: Message) => (
    <Card
      key={message.id}
      elevation={3}
      sx={{
        borderRadius: { xs: 2, sm: 3 },
        overflow: 'hidden',
        background: colors.surface,
        backdropFilter: 'blur(20px)',
        border: '1px solid rgba(59, 130, 246, 0.1)',
        transition: 'all 0.3s ease',
        '&:hover': {
          transform: 'translateY(-4px)',
          boxShadow: '0 12px 30px rgba(59, 130, 246, 0.15)',
        },
      }}
    >
      <CardContent sx={{ p: { xs: 2, sm: 3 } }}>
        {/* メッセージ内容 */}
      </CardContent>
    </Card>
  ))}
</Stack>
```

</div>
<div>

**レスポンシブ対応**
- `{ xs: 2, sm: 3 }` でサイズ別指定
- Material-UI のブレークポイントシステム活用
- モバイルファーストでパディング調整
- ホバー効果でインタラクション改善

</div>
</div>

---

## 4.2 完成したメッセージ機能

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 最終的な構成
const App = () => {
  // 状態管理
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isPosting, setIsPosting] = useState<boolean>(false);

  // バリデーション
  const validateMessage = (message: string): string | null => {
    if (!message.trim()) return 'メッセージを入力してください';
    if (message.length > 500) return '500文字以内で入力してください';
    return null;
  };

  // 相対時間表示
  const formatRelativeTime = (dateString: string): string => {
    // 実装済み
  };

  // 投稿処理
  const handlePost = async (e: FormEvent) => {
    // 実装済み
  };

  // 削除処理
  const handleDeleteMessage = (messageId: number): void => {
    // 実装済み
  };

  return (
    // JSX
  );
};
```

</div>
<div>

**実装完了のチェックリスト**

✅ テキスト投稿機能
✅ メッセージ一覧表示
✅ 削除機能
✅ バリデーション
✅ ローディング状態
✅ 相対時間表示
✅ レスポンシブデザイン
✅ エラーハンドリング
✅ 型安全性

**TypeScript の活用ポイント**
- 段階的な型定義追加
- 関数の引数・戻り値型明示
- イベントハンドラの適切な型指定
- 配列操作の型安全性

</div>
</div>

---

# 5. 次回の予告

## 5.1 次回の内容（第17回）

次回は TypeScript で画像アップロード機能を実装します：

- File API の型安全な使用方法
- 画像プレビュー機能の実装
- 画像付きメッセージの投稿
- ファイルバリデーションの追加
- 必要になった時点で `Message` 型に `image?` プロパティを追加

<v-click>

## 5.2 今日の宿題 📚

1. 今日実装したメッセージ機能をいろいろ試してみる
2. TypeScript の段階的な型定義の考え方を復習する
3. React の状態管理パターンについて理解を深める
4. Material-UI のレスポンシブシステムを調べてみる

</v-click>

---
layout: section
---

# お疲れさまでした！ 🎉

## 次回は画像アップロード機能を作ります！