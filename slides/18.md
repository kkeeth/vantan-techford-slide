---
theme: default
background: https://picsum.photos/1920/1080
class: text-center
highlighter: shiki
lineNumbers: true
info: |
  ## TypeScript + React ハンズオン講座
  第18回：チャットアプリ開発（データ永続化機能編）
fonts:
  sans: "Josefin Sans"
  serif: "Noto Sans JP"
  mono: "Fira Code"

drawings:
  persist: false
transition: slide-left
title: TypeScript/React 入門講義
---

# TypeScript + React<br>ハンズオン講座

## 第18回：チャットアプリ開発<br>データ永続化機能編

<div class="pt-12">
  <span @click="$slidev.nav.next" class="px-2 py-1 rounded cursor-pointer" hover="bg-white bg-opacity-10">
    Press Space for next page <carbon:arrow-right class="inline"/>
  </span>
</div>

<div class="abs-br m-6 flex gap-2">
  <button @click="$slidev.nav.openInEditor()" title="Open in Editor" class="text-xl slidev-icon-btn opacity-50 !border-none !hover:text-white">
    <carbon:edit />
  </button>
</div>

<style>
h1 {
  background-color: #fff;
  background-image: none;
}
</style>

---
layout: section
---

# 出席確認✋️

---
layout: default
---

# 本日の内容

<Toc minDepth="2" maxDepth="2" />

<style>
h2 {
  margin: 1rem 0;
}
</style>

## 👉️ TypeScript でデータ永続化機能を実装しよう！

---
layout: section
---

# データ永続化機能の実装

---

# 目次

## 1. データ永続化の必要性と Dexie.js のインストール
## 2. TypeScript でのデータベーススキーマ定義
## 3. メッセージの保存・読み込み機能
## 4. アプリ起動時のデータ復元

※ データが消えてしまう問題を解決するため，必要になった時点でライブラリを追加します．

<style>
h2 {
  margin-bottom: .5rem;
}
</style>

---

# 1. データ永続化の必要性と Dexie.js のインストール

## 1.1 ページリロードでデータが消えてしまう問題

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 現在の状況：ページリロードでメッセージが消える
const App = () => {
  const [messages, setMessages] = useState<Message[]>([]);

  // ページリロード時に messages は空配列に戻る
  // → ユーザーが投稿したメッセージが全て消失

  // データ永続化が必要！
};
```

</div>
<div>

**現在の問題点**
- ページリロードでメッセージが全て消える
- ブラウザを閉じるとデータが失われる
- 実用的なアプリにするためには永続化が必要

**解決策：Dexie.js**
- ブラウザの IndexedDB を簡単に使えるライブラリ
- TypeScript 完全対応
- オフラインでも動作

</div>
</div>

---

## 1.2 Dexie.js が必要になったのでインストール

<div grid="~ cols-2 gap-4">
<div>

```bash
# データ永続化ライブラリをインストール
npm install dexie

# TypeScript の型定義も一緒にインストールされる
```

</div>
<div>

**Dexie.js の特徴**
- IndexedDB のラッパーライブラリ
- 複雑な IndexedDB API を簡単に使用可能
- TypeScript でのスキーマ定義が可能
- Promise ベースの API
- React との相性が良い

</div>
</div>

---

## 1.3 データベース設定ファイルの作成が必要になったので追加

<div grid="~ cols-2 gap-4">
<div>

```tsx
// データベース管理が必要になったので設定ファイルを作成
// src/db.ts
import Dexie, { Table } from 'dexie';
import type { Message } from './types';

// データベースクラスを定義
export class ChatDatabase extends Dexie {
  // テーブルの型定義
  messages!: Table<Message>;

  constructor() {
    super('ChatDatabase');

    // スキーマのバージョン管理
    this.version(1).stores({
      messages: '++id, text, date, image'
    });
  }
}

// データベースインスタンスをエクスポート
export const db = new ChatDatabase();
```

</div>
<div>

**データベース設定のポイント**
- `Dexie` クラスを継承してデータベースクラス作成
- `Table<Message>` で型安全なテーブル定義
- `++id` で自動インクリメント主キー
- `version(1)` でスキーマバージョン管理
- TypeScript の恩恵で型安全なDB操作

</div>
</div>

---

# 2. TypeScript でのデータベーススキーマ定義

## 2.1 Message 型にデータベース ID を追加する必要が出てきた

<div grid="~ cols-2 gap-4">
<div>

```tsx
// データベース使用に伴い Message 型を更新
// src/types.ts
export type Message = {
  id?: number; // Dexie が自動生成するので optional
  text: string;
  date: string;
  image?: string;
  createdAt?: Date; // 検索・ソート用のタイムスタンプも追加
};
```

</div>
<div>

**型定義の更新理由**
- `id?` でオプショナルに変更（Dexie が自動生成）
- `createdAt?` でタイムスタンプを追加
- 既存コードとの互換性を保持
- データベース操作に適した型構造

</div>
</div>

---

## 2.2 データベース操作関数が必要になったので追加

<div grid="~ cols-2 gap-4">
<div>

```tsx
// データベース操作が必要になったので関数を作成
// src/db.ts に追加

// メッセージを保存
export const saveMessage = async (message: Omit<Message, 'id'>): Promise<number> => {
  const messageWithTimestamp = {
    ...message,
    createdAt: new Date(),
  };

  return await db.messages.add(messageWithTimestamp);
};

// 全メッセージを取得（新しい順）
export const getAllMessages = async (): Promise<Message[]> => {
  return await db.messages
    .orderBy('createdAt')
    .reverse()
    .toArray();
};

// メッセージを削除
export const deleteMessage = async (id: number): Promise<void> => {
  await db.messages.delete(id);
};
```

</div>
<div>

**データベース操作関数のポイント**
- `Omit<Message, 'id'>` で ID を除外した型
- `async/await` で非同期処理を型安全に
- `orderBy('createdAt').reverse()` で新しい順にソート
- 各関数の戻り値型を明示
- エラーハンドリングは呼び出し側で実装

</div>
</div>

---

# 3. メッセージの保存・読み込み機能

## 3.1 投稿処理をデータベース対応に更新

<div grid="~ cols-2 gap-4">
<div>

```tsx
// データベース保存が必要になったので import を追加
import { saveMessage, getAllMessages, deleteMessage } from './db';

const App = () => {
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isPosting, setIsPosting] = useState<boolean>(false);
  const [image, setImage] = useState<File | null>(null);

  // 投稿処理をデータベース対応に更新
  const handlePost = async (e: FormEvent) => {
    e.preventDefault();

    const error = validateMessage(text);
    if (error) {
      alert(error);
      return;
    }

    setIsPosting(true);

    try {
      const newMessage = {
        text: text.trim(),
        date: new Date().toLocaleString(),
      };
```

</div>
<div>

```tsx
      if (image) {
        const reader = new FileReader();
        reader.onload = async () => {
          const messageWithImage = {
            ...newMessage,
            image: reader.result as string,
          };

          // データベースに保存
          await saveMessage(messageWithImage);
          // 画面を更新
          await loadMessages();
        };
        reader.readAsDataURL(image);
      } else {
        // データベースに保存
        await saveMessage(newMessage);
        // 画面を更新
        await loadMessages();
      }

      setText('');
      setImage(null);
    } catch (error) {
      console.error('投稿エラー:', error);
      alert('投稿に失敗しました');
    } finally {
      setIsPosting(false);
    }
  };
```

</div>
</div>

<div grid="~ cols-2 gap-4">
<div>

**データベース対応のポイント**
- `saveMessage()` でデータベースに永続化
- `loadMessages()` で最新データを再取得
- エラーハンドリングで DB エラーに対応
- 非同期処理の型安全性を保持

</div>
</div>

---

## 3.2 メッセージ読み込み関数の実装

<div grid="~ cols-2 gap-4">
<div>

```tsx
// メッセージ読み込みが必要になったので関数を追加
const loadMessages = async (): Promise<void> => {
  try {
    const allMessages = await getAllMessages();
    setMessages(allMessages);
  } catch (error) {
    console.error('メッセージ読み込みエラー:', error);
    // エラー時は既存の state を保持
  }
};

// 削除処理もデータベース対応に更新
const handleDeleteMessage = async (messageId: number): Promise<void> => {
  if (!messageId) {
    console.warn('Invalid message ID');
    return;
  }

  const targetMessage = messages.find(m => m.id === messageId);
  if (!targetMessage) {
    console.warn(`Message with id ${messageId} not found`);
    return;
  }
```

</div>
<div>

```tsx
  const previewText = targetMessage.text.length > 20
    ? `${targetMessage.text.substring(0, 20)}...`
    : targetMessage.text;

  if (window.confirm(`「${previewText}」を削除しますか？`)) {
    try {
      // データベースから削除
      await deleteMessage(messageId);
      // 画面を更新
      await loadMessages();
    } catch (error) {
      console.error('削除エラー:', error);
      alert('削除に失敗しました');
    }
  }
};
```

</div>
</div>

<div grid="~ cols-2 gap-4">
<div>

**読み込み・削除処理のポイント**
- `loadMessages()` で DB から最新データを取得
- エラー時は既存の state を保持
- 削除時もDBと画面の両方を更新
- TypeScript で型安全なエラーハンドリング

</div>
</div>

---

# 4. アプリ起動時のデータ復元

## 4.1 初回読み込み時にデータを復元する機能が必要になった

<div grid="~ cols-2 gap-4">
<div>

```tsx
// アプリ起動時のデータ復元が必要になったので useEffect を追加
import { useEffect } from 'react';

const App = () => {
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isPosting, setIsPosting] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true); // 読み込み状態を追加

  // アプリ起動時にデータを読み込み
  useEffect(() => {
    const initializeApp = async () => {
      try {
        await loadMessages();
      } catch (error) {
        console.error('アプリ初期化エラー:', error);
        // エラーでもアプリは使用可能にする
      } finally {
        setIsLoading(false);
      }
    };

    initializeApp();
  }, []); // 空の依存配列で初回のみ実行
```

</div>
<div>

```tsx
  // 読み込み中の表示
  if (isLoading) {
    return (
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
        }}
      >
        <Typography variant="h6" color="text.secondary">
          💬 チャットを読み込み中...
        </Typography>
      </Box>
    );
  }

  return (
    // 既存の JSX
  );
};
```

</div>
</div>

<div grid="~ cols-2 gap-4">
<div>

**初期化処理のポイント**
- `useEffect` でアプリ起動時にデータ読み込み
- `isLoading` 状態で読み込み中を表示
- エラー時もアプリは使用可能
- 空の依存配列で初回のみ実行

</div>
</div>

---

## 4.2 データベースエラーハンドリングの強化

<div grid="~ cols-2 gap-4">
<div>

```tsx
// より堅牢なエラーハンドリングが必要になったので強化
const loadMessages = async (): Promise<void> => {
  try {
    const allMessages = await getAllMessages();
    setMessages(allMessages);
  } catch (error) {
    console.error('メッセージ読み込みエラー:', error);

    // IndexedDB が使用できない場合の対処
    if (error instanceof Error && error.message.includes('IndexedDB')) {
      console.warn('IndexedDB が利用できません。メモリ上でのみ動作します。');
    }

    // エラー時は空配列で初期化（アプリは動作可能）
    setMessages([]);
  }
};
```

</div>
<div>

```tsx
// データベース操作の汎用エラーハンドラ
const handleDatabaseError = (operation: string, error: unknown): void => {
  console.error(`${operation}エラー:`, error);

  if (error instanceof Error) {
    // 特定のエラータイプに応じた処理
    if (error.message.includes('QuotaExceededError')) {
      alert('ストレージ容量が不足しています。古いメッセージを削除してください。');
    } else if (error.message.includes('NotFoundError')) {
      alert('データが見つかりませんでした。');
    } else {
      alert(`操作に失敗しました：${error.message}`);
    }
  } else {
    alert('不明なエラーが発生しました。');
  }
};
```

</div>
</div>

<div grid="~ cols-2 gap-4">
<div>

**エラーハンドリング強化**
- データベース固有エラーの識別
- ストレージ容量不足の対応
- エラー時でもアプリ動作を継続
- ユーザーフレンドリーなエラーメッセージ

</div>
</div>

---

# 5. 完成と動作確認

## 5.1 データ永続化機能の最終確認

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 最終的なアプリの構成
const App = () => {
  // 状態管理
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isPosting, setIsPosting] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [image, setImage] = useState<File | null>(null);

  // 初期化処理
  useEffect(() => {
    const initializeApp = async () => {
      try {
        await loadMessages();
      } finally {
        setIsLoading(false);
      }
    };
    initializeApp();
  }, []);

  // データベース操作関数
  const loadMessages = async (): Promise<void> => {
    // 実装済み
  };

  const handlePost = async (e: FormEvent) => {
    // データベース対応実装済み
  };

  const handleDeleteMessage = async (messageId: number): Promise<void> => {
    // データベース対応実装済み
  };

  return (
    // JSX実装済み
  );
};
```

</div>
<div>

**機能テストチェックリスト**

✅ メッセージの永続化保存
✅ ページリロード時のデータ復元
✅ 画像付きメッセージの保存
✅ メッセージの削除
✅ エラーハンドリング
✅ 読み込み状態の表示
✅ TypeScript 型安全性
✅ オフライン対応

**確認方法**
1. メッセージを投稿
2. ページをリロード
3. メッセージが復元されることを確認

</div>
</div>

---

## 5.2 パフォーマンスとストレージ管理

<div grid="~ cols-2 gap-4">
<div>

```tsx
// ストレージ使用量の監視が必要になったら追加
// src/db.ts に追加

// ストレージ使用量を取得
export const getStorageInfo = async () => {
  try {
    const messageCount = await db.messages.count();
    const totalSize = await db.messages.toArray().then(messages => {
      return messages.reduce((total, message) => {
        const textSize = new Blob([message.text]).size;
        const imageSize = message.image ? new Blob([message.image]).size : 0;
        return total + textSize + imageSize;
      }, 0);
    });

    return {
      messageCount,
      totalSize: Math.round(totalSize / 1024), // KB単位
    };
  } catch (error) {
    console.error('ストレージ情報取得エラー:', error);
    return { messageCount: 0, totalSize: 0 };
  }
};
```

</div>
<div>

```tsx
// 古いメッセージを削除（容量管理）
export const cleanupOldMessages = async (keepCount: number = 100) => {
  try {
    const allMessages = await db.messages.orderBy('createdAt').reverse().toArray();
    if (allMessages.length > keepCount) {
      const messagesToDelete = allMessages.slice(keepCount);
      const idsToDelete = messagesToDelete.map(m => m.id!);
      await db.messages.bulkDelete(idsToDelete);
    }
  } catch (error) {
    console.error('メッセージクリーンアップエラー:', error);
  }
};
```

</div>
</div>

<div grid="~ cols-2 gap-4">
<div>

**ストレージ管理のポイント**
- メッセージ数と使用容量の監視
- 自動クリーンアップ機能
- `bulkDelete` で効率的な一括削除
- エラー時も動作継続

**運用での考慮事項**
- 定期的な古いメッセージ削除
- 画像サイズの制限
- ユーザーへのストレージ使用量通知
- バックアップ・エクスポート機能

</div>
</div>

---

# 6. 次回の予告

## 6.1 次回の内容（第19回）

次回は TypeScript でアプリの仕上げと機能拡張を行います：

- 設定画面の追加（ダークモード等）
- エクスポート・インポート機能
- パフォーマンス最適化
- TypeScript での React.memo 活用
- プロダクション向けの最終調整

<v-click>

## 6.2 今日の宿題 📚

1. 今日実装したデータ永続化機能をいろいろ試してみる
2. Dexie.js の公式ドキュメントを読んでみる
3. IndexedDB について調べてみる
4. TypeScript での非同期処理パターンを復習する

</v-click>

---
layout: section
---

# お疲れさまでした！ 🎉

## 次回はアプリの仕上げを行います！