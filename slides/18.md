---
theme: default
background: https://picsum.photos/1920/1080
class: text-center
highlighter: shiki
lineNumbers: true
info: |
  ## TypeScript + React ハンズオン講座
  第18回：チャットアプリ開発（データ永続化機能編）
fonts:
  sans: "Josefin Sans"
  serif: "Noto Sans JP"
  mono: "Fira Code"

drawings:
  persist: false
transition: slide-left
title: TypeScript/React 入門講義
---

# TypeScript + React<br>ハンズオン講座

## 第18回：チャットアプリ開発<br>データ永続化機能編

<div class="pt-12">
  <span @click="$slidev.nav.next" class="px-2 py-1 rounded cursor-pointer" hover="bg-white bg-opacity-10">
    Press Space for next page <carbon:arrow-right class="inline"/>
  </span>
</div>

<div class="abs-br m-6 flex gap-2">
  <button @click="$slidev.nav.openInEditor()" title="Open in Editor" class="text-xl slidev-icon-btn opacity-50 !border-none !hover:text-white">
    <carbon:edit />
  </button>
</div>

<style>
h1 {
  background-color: #fff;
  background-image: none;
}
</style>

---
layout: section
---

# 出席確認✋️

---
layout: default
---

# 本日の内容

<Toc minDepth="2" maxDepth="2" />

<style>
h2 {
  margin: 1rem 0;
}
</style>

## 👉️ TypeScript でデータ永続化機能を実装しよう！

---
layout: section
---

# データ永続化機能の実装

---

# 目次

## 1. データ永続化の必要性と Dexie.js のインストール
## 2. TypeScript でのデータベーススキーマ定義
## 3. メッセージの保存・読み込み機能
## 4. アプリ起動時のデータ復元

※ データが消えてしまう問題を解決するため，必要になった時点でライブラリを追加します．

<style>
h2 {
  margin-bottom: .5rem;
}
</style>

---

# 1. データ永続化の必要性と Dexie.js のインストール

## 1.1 ページリロードでデータが消えてしまう問題

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 現在の状況：ページリロードでメッセージが消える
const App = () => {
  const [messages, setMessages] = useState<Message[]>([]);

  // ページリロード時に messages は空配列に戻る
  // → ユーザーが投稿したメッセージが全て消失

  // データ永続化が必要！
};
```

</div>
<div>

**現在の問題点**
- ページリロードでメッセージが全て消える
- ブラウザを閉じるとデータが失われる
- 実用的なアプリにするためには永続化が必要

**解決策：Dexie.js**
- ブラウザの IndexedDB を簡単に使えるライブラリ
- TypeScript 完全対応
- オフラインでも動作

</div>
</div>

---

## 1.2 Dexie.js が必要になったのでインストール

<div grid="~ cols-2 gap-4">
<div>

```bash
# データ永続化ライブラリをインストール
npm install dexie

# TypeScript の型定義も一緒にインストールされる
```

</div>
<div>

**Dexie.js の特徴**
- IndexedDB のラッパーライブラリ
- 複雑な IndexedDB API を簡単に使用可能
- TypeScript でのスキーマ定義が可能
- Promise ベースの API
- React との相性が良い

</div>
</div>

---

## 1.3 App.tsx 内でデータベース設定

<div grid="~ cols-2 gap-4">
<div>

```tsx
// App.tsx の先頭で Dexie データベースを設定
// src/App.tsx
import { useEffect, useState, useCallback } from 'react';
import Dexie from 'dexie';
import './App.css';
import {
  // Material-UI のインポート...
} from '@mui/material';
import { Message, MessageWithoutId } from './types';

// データベースの設定
const db = new Dexie('ChatApp');
db.version(1).stores({
  messages: '++id, text, image, date, createdAt',
});

const MAX_MESSAGE_LENGTH = 500;

const App = () => {
  // 状態管理...
};
```

</div>
<div>

**データベース設定のポイント**
- `db.ts` は作成せず，App.tsx 内で直接設定
- `new Dexie('ChatApp')` でデータベース作成
- `version(1).stores()` でスキーマ定義
- `++id` で自動インクリメント主キー
- `createdAt` フィールドを追加

</div>
</div>

---

# 2. TypeScript の型定義の更新

## 2.1 Message 型に createdAt を追加

<div grid="~ cols-2 gap-4">
<div>

```tsx
// データベース使用に伴い Message 型を更新
// src/types.ts
export type Message = {
  id: number;
  text: string;
  date: string;
  image?: string;
  createdAt?: Date; // 検索・ソート用のタイムスタンプを追加
};
```

</div>
<div>

**型定義の更新理由**
- `createdAt?` でタイムスタンプを追加
- ソート機能で使用するため
- 既存コードとの互換性を保持
- データベース操作に適した型構造

</div>
</div>

---

## 2.2 MessageWithoutId 型の追加

<div grid="~ cols-2 gap-4">
<div>

```tsx
// src/types.ts
export type Message = {
  id: number;
  text: string;
  image?: string;
  date: string;
  createdAt?: Date;
};

export type MessageWithoutId = Omit<Message, 'id'>;
```

</div>
<div>

**MessageWithoutId 型のポイント**
- `Omit<Message, 'id'>` で ID を除外した型
- データベースに保存する前のメッセージデータ用
- 型の再利用性を向上
- Dexie が自動的に ID を生成する

</div>
</div>

---

# 3. メッセージの保存・読み込み機能

## 3.1 投稿処理をデータベース対応に更新

<div grid="~ cols-2 gap-4">
<div>

```tsx
const App = () => {
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isPosting, setIsPosting] = useState<boolean>(false);
  const [image, setImage] = useState<File | null>(null);

  // 投稿処理をデータベース対応に更新
  const handlePost = (e: React.FormEvent<HTMLFormElement>): void => {
    e.preventDefault();

    const error = validateMessage(text);
    if (error) {
      alert(error);
      return;
    }

    setIsPosting(true);

    try {
      const createdAt = new Date();
      const dateString = createdAt.toLocaleString();

      if (image) {
        const reader = new FileReader();
        reader.onload = async () => {
          const imageData = reader.result as string;

          const messageData: MessageWithoutId = {
            text: text.trim(),
            image: imageData,
            date: dateString,
            createdAt,
          };
```

</div>
<div>

```tsx
          // データベースに保存
          const id = await db.messages.add(messageData);

          const newMessage: Message = {
            id: id as number,
            ...messageData,
          };

          setMessages((prev) => [newMessage, ...prev]);
        };

        reader.readAsDataURL(image);
      } else {
        const messageData: MessageWithoutId = {
          text: text.trim(),
          image: undefined,
          date: dateString,
          createdAt,
        };

        // データベースに保存
        const id = await db.messages.add(messageData);

        const newMessage: Message = {
          id: id as number,
          ...messageData,
        };

        setMessages((prev) => [newMessage, ...prev]);
      }

      setImage(null);
      setText('');
    } finally {
      setIsPosting(false);
    }
  };
```

</div>
</div>

<div grid="~ cols-2 gap-4">
<div>

**データベース対応のポイント**
- `db.messages.add()` でデータベースに直接保存
- `MessageWithoutId` 型を使用
- 保存後に ID を取得して state を更新
- 非同期処理の型安全性を保持

</div>
</div>

---

## 3.2 削除処理をデータベース対応に更新

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 削除処理をデータベース対応に更新
const deleteMessage = async (id: number): Promise<void> => {
  const message = messages.find((m) => m.id === id);
  if (!message) return;

  const previewText =
    message.text.length > 20
      ? message.text.substring(0, 20) + '...'
      : message.text;

  if (window.confirm(`「${previewText}」を削除しますか？`)) {
    try {
      // データベースから削除
      await db.messages.delete(id);
      // 画面を更新
      setMessages((prev) => prev.filter((message) => message.id !== id));
    } catch (error) {
      console.error('削除に失敗しました:', error);
      alert('削除に失敗しました');
    }
  }
};
```

</div>
<div>

**削除処理のポイント**
- `db.messages.delete()` でデータベースから直接削除
- 削除後に state を更新
- エラーハンドリングで DB エラーに対応
- TypeScript で型安全なエラーハンドリング

</div>
</div>

---

# 4. アプリ起動時のデータ復元

## 4.1 初回読み込み時にデータを復元

<div grid="~ cols-2 gap-4">
<div>

```tsx
const App = () => {
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isPosting, setIsPosting] = useState<boolean>(false);
  const [image, setImage] = useState<File | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);

  // メッセージ読み込み
  useEffect(() => {
    const loadMessages = async (): Promise<void> => {
      try {
        const allMessages = await db.messages.toArray();
        setMessages(allMessages.reverse());
      } catch (error) {
        console.error('メッセージの読み込みに失敗しました:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadMessages();
  }, []);
```

</div>
<div>

```tsx
  // 読み込み中の表示
  if (isLoading) {
    return (
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        <Typography variant="h6">読み込み中...</Typography>
      </Box>
    );
  }

  return (
    // 既存の JSX
  );
};
```

</div>
</div>

<div grid="~ cols-2 gap-4">
<div>

**初期化処理のポイント**
- `useEffect` でアプリ起動時にデータ読み込み
- `db.messages.toArray()` で全メッセージを取得
- `.reverse()` で新しい順に並べ替え
- `isLoading` 状態で読み込み中を表示
- 空の依存配列で初回のみ実行

</div>
</div>


---

# 5. 完成と動作確認

## 5.1 データ永続化機能の最終確認

<div grid="~ cols-2 gap-4">
<div>

```tsx
// 最終的なアプリの構成
const App = () => {
  // 状態管理
  const [text, setText] = useState<string>('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isPosting, setIsPosting] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [image, setImage] = useState<File | null>(null);

  // 初期化処理
  useEffect(() => {
    const initializeApp = async () => {
      try {
        await loadMessages();
      } finally {
        setIsLoading(false);
      }
    };
    initializeApp();
  }, []);

  // データベース操作関数
  const loadMessages = async (): Promise<void> => {
    // 実装済み
  };

  const handlePost = async (e: FormEvent) => {
    // データベース対応実装済み
  };

  const handleDeleteMessage = async (messageId: number): Promise<void> => {
    // データベース対応実装済み
  };

  return (
    // JSX実装済み
  );
};
```

</div>
<div>

**機能テストチェックリスト**

✅ メッセージの永続化保存
✅ ページリロード時のデータ復元
✅ 画像付きメッセージの保存
✅ メッセージの削除
✅ エラーハンドリング
✅ 読み込み状態の表示
✅ TypeScript 型安全性
✅ オフライン対応

**確認方法**
1. メッセージを投稿
2. ページをリロード
3. メッセージが復元されることを確認

</div>
</div>

---

# 6. 次回の予告

## 6.1 次回の内容（第19回）

次回は TypeScript でアプリの仕上げと機能拡張を行います：

- 設定画面の追加（ダークモード等）
- エクスポート・インポート機能
- パフォーマンス最適化
- TypeScript での React.memo 活用
- プロダクション向けの最終調整

<v-click>

## 6.2 今日の宿題 📚

1. 今日実装したデータ永続化機能をいろいろ試してみる
2. Dexie.js の公式ドキュメントを読んでみる
3. IndexedDB について調べてみる
4. TypeScript での非同期処理パターンを復習する

</v-click>

---
layout: section
---

# お疲れさまでした！ 🎉

## 次回はアプリの仕上げを行います！